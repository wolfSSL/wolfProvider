/*
 * Copyright (C) 2006-2025 wolfSSL Inc.
 *
 * This file is part of wolfProvider.
 *
 * wolfProvider is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3 of the License, or
 * (at your option) any later version.
 *
 * wolfProvider is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with wolfProvider. If not, see <http://www.gnu.org/licenses/>.
 */

#include "test_fips_baseline.h"

/* Test message for signing */
static const unsigned char test_msg[] = "Test message for ECDSA signing";
static const size_t test_msg_len = sizeof(test_msg) - 1;

/* Precomputed signatures removed - tests now observe behavior rather than verify */

/**
 * Helper: Generate EC key with specified curve
 * Returns 1 on success, 0 on failure
 */
static int generate_ec_key(OSSL_LIB_CTX *libctx, const char *curve_name,
                          EVP_PKEY **pkey_out)
{
    EVP_PKEY_CTX *kctx = NULL;
    EVP_PKEY *pkey = NULL;
    OSSL_PARAM params[2];
    char curve_buf[32];
    int ret = 0;

    kctx = EVP_PKEY_CTX_new_from_name(libctx, "EC", NULL);
    if (kctx == NULL || EVP_PKEY_keygen_init(kctx) <= 0)
        goto cleanup;

    snprintf(curve_buf, sizeof(curve_buf), "%s", curve_name);
    params[0] = OSSL_PARAM_construct_utf8_string(OSSL_PKEY_PARAM_GROUP_NAME,
                                                  curve_buf, 0);
    params[1] = OSSL_PARAM_construct_end();

    if (EVP_PKEY_CTX_set_params(kctx, params) <= 0)
        goto cleanup;

    if (EVP_PKEY_keygen(kctx, &pkey) <= 0)
        goto cleanup;

    *pkey_out = pkey;
    pkey = NULL;
    ret = 1;

cleanup:
    EVP_PKEY_free(pkey);
    EVP_PKEY_CTX_free(kctx);
    return ret;
}


/**
 * Helper: Sign message with EC key and specified digest
 * Returns 1 on success, 0 on failure
 *
 * NOTE: Uses EVP_DigestSignInit_ex with explicit libctx to ensure
 * the correct provider handles the signature operation.
 */
static int sign_message(OSSL_LIB_CTX *libctx, EVP_PKEY *pkey, const char *mdname,
                       const unsigned char *msg, size_t msg_len,
                       unsigned char *sig, size_t *sig_len)
{
    EVP_MD_CTX *mctx = NULL;
    int ret = 0;

    mctx = EVP_MD_CTX_new();
    if (mctx == NULL)
        goto cleanup;

    /* Use EVP_DigestSignInit_ex to explicitly specify the library context.
     * This ensures the signature operation uses the correct provider.
     * Without this, OpenSSL may route to the default provider even if
     * the key was generated by a different provider.
     */
    if (EVP_DigestSignInit_ex(mctx, NULL, mdname, libctx, NULL, pkey, NULL) <= 0) {
        ERR_clear_error();
        goto cleanup;
    }

    if (EVP_DigestSign(mctx, sig, sig_len, msg, msg_len) <= 0) {
        ERR_clear_error();
        goto cleanup;
    }

    ret = 1;

cleanup:
    EVP_MD_CTX_free(mctx);
    return ret;
}

/* verify_signature helper removed - not needed for observational tests */

/**
 * Test 1: P-192 keygen should FAIL (< 112-bit security strength)
 */
static int test_p192_keygen_blocked(OSSL_LIB_CTX *libctx, const char *provider)
{
    EVP_PKEY *pkey = NULL;
    int ret = TEST_FAILURE;

    /* P-192 keygen should FAIL */
    if (generate_ec_key(libctx, "prime192v1", &pkey) != 0) {
        TEST_ERROR("    [%s] P-192 keygen succeeded (should have failed)", provider);
        goto cleanup;
    }

    TEST_INFO("    [%s] ✓ P-192 keygen correctly blocked", provider);
    ret = TEST_SUCCESS;

cleanup:
    EVP_PKEY_free(pkey);
    return ret;
}

/**
 * Test 2: P-256 keygen should SUCCEED (128-bit security strength)
 */
static int test_p256_keygen_allowed(OSSL_LIB_CTX *libctx, const char *provider)
{
    EVP_PKEY *pkey = NULL;
    int ret = TEST_FAILURE;

    /* P-256 keygen should SUCCEED */
    if (generate_ec_key(libctx, "prime256v1", &pkey) != 1) {
        TEST_ERROR("    [%s] P-256 keygen failed (should have succeeded)", provider);
        goto cleanup;
    }

    TEST_INFO("    [%s] ✓ P-256 keygen works correctly", provider);
    ret = TEST_SUCCESS;

cleanup:
    EVP_PKEY_free(pkey);
    return ret;
}

/**
 * Test 3: P-256 + SHA1 signing - check if blocked
 */
static int test_p256_sha1_signing(OSSL_LIB_CTX *libctx, const char *provider,
                                  int expected_blocked)
{
    EVP_PKEY *pkey = NULL;
    unsigned char sig[256];
    size_t sig_len = sizeof(sig);
    int ret = TEST_FAILURE;
    int was_blocked;

    if (generate_ec_key(libctx, "prime256v1", &pkey) != 1) {
        TEST_ERROR("    [%s] Failed to generate P-256 key", provider);
        goto cleanup;
    }

    was_blocked = (sign_message(libctx, pkey, "SHA1", test_msg, test_msg_len,
                                sig, &sig_len) != 1);

    if (expected_blocked && !was_blocked) {
        TEST_ERROR("    [%s] P-256+SHA1 signing should be BLOCKED but was ALLOWED",
                   provider);
        goto cleanup;
    }
    if (!expected_blocked && was_blocked) {
        TEST_ERROR("    [%s] P-256+SHA1 signing should be ALLOWED but was BLOCKED",
                   provider);
        goto cleanup;
    }

    TEST_INFO("    [%s] P-256+SHA1 signing correctly %s", provider,
              was_blocked ? "BLOCKED" : "ALLOWED");
    ret = TEST_SUCCESS;

cleanup:
    EVP_PKEY_free(pkey);
    return ret;
}

/**
 * Test: P-256 + SHA256 signing - should always work
 */
static int test_p256_sha256_signing(OSSL_LIB_CTX *libctx, const char *provider)
{
    EVP_PKEY *pkey = NULL;
    unsigned char sig[256];
    size_t sig_len = sizeof(sig);
    int ret = TEST_FAILURE;

    if (generate_ec_key(libctx, "prime256v1", &pkey) != 1) {
        TEST_ERROR("    [%s] Failed to generate P-256 key", provider);
        goto cleanup;
    }

    /* SHA256 signing should always work */
    if (sign_message(libctx, pkey, "SHA256", test_msg, test_msg_len,
                     sig, &sig_len) != 1) {
        TEST_ERROR("    [%s] P-256+SHA256 signing FAILED (should work)", provider);
        goto cleanup;
    }

    TEST_INFO("    [%s] ✓ P-256+SHA256 signing works correctly", provider);
    ret = TEST_SUCCESS;

cleanup:
    EVP_PKEY_free(pkey);
    return ret;
}

/* test_p256_sha1_verify_allowed removed - needs precomputed valid signature */

/**
 * Main ECDSA key size restriction test
 */
int test_ecdsa_key_size_restrictions(void)
{
    TEST_INFO("Testing ECDSA key size restrictions with both providers:");

    /* Test 1: P-192 keygen blocked */
    TEST_INFO("  Test 1: P-192 keygen (should fail)");
    TEST_INFO("    Testing with wolfProvider...");
    if (test_p192_keygen_blocked(wpLibCtx, "wolfProvider") != TEST_SUCCESS)
        return TEST_FAILURE;
    TEST_INFO("    Testing with default (baseline)...");
    if (test_p192_keygen_blocked(osslLibCtx, "default") != TEST_SUCCESS)
        return TEST_FAILURE;

    /* Test 2: P-256 keygen allowed */
    TEST_INFO("  Test 2: P-256 keygen (should succeed)");
    TEST_INFO("    Testing with wolfProvider...");
    if (test_p256_keygen_allowed(wpLibCtx, "wolfProvider") != TEST_SUCCESS)
        return TEST_FAILURE;
    TEST_INFO("    Testing with default (baseline)...");
    if (test_p256_keygen_allowed(osslLibCtx, "default") != TEST_SUCCESS)
        return TEST_FAILURE;

    /* Test 3: P-256 + SHA1 signing - should be BLOCKED by both providers */
    TEST_INFO("  Test 3: P-256 + SHA1 signing (should be blocked)");
    TEST_INFO("    Testing with wolfProvider...");
    if (test_p256_sha1_signing(wpLibCtx, "wolfProvider", 1) != TEST_SUCCESS)
        return TEST_FAILURE;
    TEST_INFO("    Testing with default (baseline)...");
    if (test_p256_sha1_signing(osslLibCtx, "default", 1) != TEST_SUCCESS)
        return TEST_FAILURE;
    TEST_INFO("    ✓ Both providers correctly block ECDSA+SHA1 signing");

    /* Test 4: P-256 + SHA256 signing - should WORK with both providers */
    TEST_INFO("  Test 4: P-256 + SHA256 signing (should succeed)");
    TEST_INFO("    Testing with wolfProvider...");
    if (test_p256_sha256_signing(wpLibCtx, "wolfProvider") != TEST_SUCCESS)
        return TEST_FAILURE;
    TEST_INFO("    Testing with default (baseline)...");
    if (test_p256_sha256_signing(osslLibCtx, "default") != TEST_SUCCESS)
        return TEST_FAILURE;

    TEST_INFO("✓ All ECDSA key size restrictions properly enforced");
    return TEST_SUCCESS;
}
